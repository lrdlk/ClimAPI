# ğŸš€ PROMPT CURSOR/WINDSURF - TESTING CLIMAPI POR ETAPAS

## INSTRUCCIONES INICIALES

**Antes de comenzar:**
1. Copia este prompt completo en Cursor/Windsurf
2. Reemplaza `[PROYECTO_PATH]` con la ruta real (ej: `/home/user/ClimAPI`)
3. Reemplaza `[TU_USUARIO]` con tu nombre
4. Ejecuta etapa por etapa segÃºn las instrucciones

---

## ğŸ“‹ CONTEXTO DEL PROYECTO

**Nombre:** ClimAPI v1.0.0  
**Objetivo:** Dashboard meteorolÃ³gico con 8+ fuentes de datos  
**Stack:** FastAPI + Streamlit + Pytest + Pinggy  
**Usuario:** [TU_USUARIO]  
**Ruta Proyecto:** [PROYECTO_PATH]  

---

## ğŸ¯ ESTRUCTURA DE PRUEBAS

```
ETAPA 1: Validar Setup & Dependencias (15 min)
  â”œâ”€ Verificar Python 3.9+
  â”œâ”€ Verificar virtualenv activo
  â”œâ”€ Verificar dependencias instaladas
  â””â”€ Verificar estructura de carpetas

ETAPA 2: Tests Unitarios - Clientes (45 min)
  â”œâ”€ Tests SIATA Client (8 tests)
  â”œâ”€ Tests Radar IDEAM Client (6 tests)
  â”œâ”€ Tests Open-Meteo Client (7 tests)
  â”œâ”€ Tests Cache Manager (5 tests)
  â””â”€ Reporte de cobertura (target >70%)

ETAPA 3: Tests de IntegraciÃ³n - APIs Reales (60 min)
  â”œâ”€ Tests de Endpoints FastAPI (5 tests)
  â”œâ”€ Tests de NormalizaciÃ³n de Datos (4 tests)
  â”œâ”€ Tests de CachÃ© Integrado (3 tests)
  â”œâ”€ Tests de Fallbacks (3 tests)
  â””â”€ Health Check del Backend

ETAPA 4: VerificaciÃ³n de Backend & Config (30 min)
  â”œâ”€ Validar config/settings.py
  â”œâ”€ Validar estructura de mÃ³dulos
  â”œâ”€ Validar imports correctos
  â””â”€ Health check FastAPI

ETAPA 5: Setup Pinggy Tunnel (20 min)
  â”œâ”€ Verificar conexiÃ³n SSH
  â”œâ”€ Crear tunnel con Pinggy
  â”œâ”€ Obtener URL pÃºblica
  â””â”€ Probar acceso a API

ETAPA 6: Streamlit Dashboard (30 min)
  â”œâ”€ Verificar instalaciÃ³n Streamlit
  â”œâ”€ Verificar cliente API funciona
  â”œâ”€ Iniciar dashboard
  â””â”€ Probar interactividad

ETAPA 7: Testing End-to-End (30 min)
  â”œâ”€ APIs Reales â†’ Backend
  â”œâ”€ Backend â†’ CachÃ©
  â”œâ”€ CachÃ© â†’ Streamlit
  â””â”€ Streamlit â†’ Visualizaciones
```

---

## âš¡ ETAPA 1: VALIDAR SETUP & DEPENDENCIAS

**Tiempo:** 15 minutos  
**Objetivo:** Asegurar ambiente listo

### TAREA 1.1: Verificar Python

```bash
# En Cursor/Windsurf Terminal:
python --version
# Resultado esperado: Python 3.9+ (ej: Python 3.11.5)

# Verificar pip
pip --version
# Resultado esperado: pip 24.x.x

# Verificar virtualenv activo
which python
# Resultado esperado: Ruta que contenga "/venv/" o "/.venv/"
```

**Si falla:**
```bash
# Crear virtualenv
cd [PROYECTO_PATH]
python -m venv venv

# Activar
# Linux/Mac:
source venv/bin/activate
# Windows:
venv\Scripts\activate
```

### TAREA 1.2: Instalar Dependencias

```bash
cd [PROYECTO_PATH]

# Instalar requirements.txt
pip install -r requirements.txt -q

# Instalar dependencias de testing
pip install pytest pytest-cov pytest-asyncio pytest-mock httpx -q

# Instalar Streamlit
pip install streamlit plotly -q

# Verificar instalaciones
pip list | grep -E "pytest|fastapi|streamlit|httpx"
```

**DeberÃ­a mostrar:**
```
fastapi           0.109.0
httpx              0.25.2
plotly            5.18.0
pytest            7.4.3
pytest-asyncio    0.23.1
pytest-cov        4.1.0
pytest-mock       3.12.0
streamlit         1.31.1
```

### TAREA 1.3: Verificar Estructura de Carpetas

```bash
cd [PROYECTO_PATH]

# Verificar estructura principal
ls -la | grep -E "config|src|tests|streamlit"

# Verificar subcarpetas
ls -la config/
ls -la src/
ls -la tests/
```

**DeberÃ­a mostrar:**
```
config/
â”œâ”€ __init__.py
â”œâ”€ settings.py
â”œâ”€ requirements_config.txt

src/
â”œâ”€ data_sources/
â”œâ”€ processing/
â”œâ”€ models/
â”œâ”€ visualizers/

tests/
â”œâ”€ test_clients/
â”œâ”€ test_integration/
â”œâ”€ conftest.py

streamlit_dashboard/
â”œâ”€ app.py
â”œâ”€ pages/
â”œâ”€ utils/
```

**Si faltan archivos:**
```bash
# Crear config/settings.py (ver ETAPA 4)
# Crear archivos faltantes en src/
# Crear estructura de tests (ver ETAPA 2)
```

### TAREA 1.4: Verificar Imports BÃ¡sicos

```bash
# En Cursor, crear archivo de test temporal:
# test_imports.py

python -c "
from config.settings import settings
from src.data_sources.siata import SIATAClient
from src.processing.cache_manager import CacheManager
print('âœ“ Todos los imports OK')
"

# Resultado esperado: âœ“ Todos los imports OK
```

**Si falla:**
```
âŒ ModuleNotFoundError: No module named 'config'
â†’ SoluciÃ³n: Revisar paths en sys.path dentro de conftest.py
```

---

## âš™ï¸ ETAPA 2: TESTS UNITARIOS - CLIENTES (45 min)

**Tiempo:** 45 minutos  
**Objetivo:** Validar clientes aisladamente sin APIs reales

### TAREA 2.1: Crear conftest.py con Fixtures

**Archivo:** `tests/conftest.py`

```python
# COPIAR COMPLETO - conftest.py

import pytest
from unittest.mock import Mock, patch
from datetime import datetime
from pathlib import Path
import sys

sys.path.insert(0, str(Path(__file__).parent.parent))

from config.settings import settings
from src.data_sources.siata import SIATAClient
from src.processing.cache_manager import CacheManager

# ========================== FIXTURES ==========================

@pytest.fixture
def test_location():
    """UbicaciÃ³n de prueba."""
    return {
        "name": "MedellÃ­n",
        "latitude": 6.2442,
        "longitude": -75.5812
    }

@pytest.fixture
def siata_client():
    """Cliente SIATA."""
    config = {"api_url": "https://www.siata.gov.co"}
    return SIATAClient(config)

@pytest.fixture
def cache_manager(tmp_path):
    """Cache Manager."""
    return CacheManager(
        cache_dir=str(tmp_path / "cache"),
        ttl_config={"current_weather": 15, "forecast": 60}
    )

@pytest.fixture
def mock_weather_response():
    """Mock de respuesta."""
    return {
        "timestamp": datetime.utcnow().isoformat(),
        "temperature": 22.5,
        "humidity": 65.0,
        "source": "test"
    }

@pytest.fixture(autouse=True)
def log_test_info(request):
    """Log de tests."""
    print(f"\n{'='*60}\nTEST: {request.node.name}\n{'='*60}")
    yield

# ======================== HOOKS ========================

def pytest_configure(config):
    """Registra marcadores."""
    config.addinivalue_line("markers", "unit: unit test")
    config.addinivalue_line("markers", "integration: integration test")
    config.addinivalue_line("markers", "slow: slow test (requires API)")
```

**Comando para crear:**
```bash
# En Cursor, crea archivo en tests/conftest.py
# Y copia el cÃ³digo arriba
```

### TAREA 2.2: Tests del SIATA Client

**Archivo:** `tests/test_clients/test_siata_client.py`

```python
import pytest
from unittest.mock import Mock, patch
from src.data_sources.siata import SIATAClient

@pytest.mark.unit
class TestSIATAClient:
    """Tests del SIATA Client."""
    
    def test_client_init(self, siata_client):
        """âœ“ Test 1: Cliente inicializa correctamente."""
        assert siata_client.base_url == "https://www.siata.gov.co"
        print("âœ“ Test 1 PASÃ“")
    
    def test_normalize_response(self, siata_client):
        """âœ“ Test 2: Normaliza respuesta correctamente."""
        raw = {"temperature": 22.5, "humidity": 65.0, "viento": 3.2}
        normalized = siata_client._normalize_siata_response(raw)
        
        assert normalized["temperature"] == 22.5
        assert normalized["humidity"] == 65.0
        assert normalized["wind_speed"] == 3.2
        print("âœ“ Test 2 PASÃ“")
    
    @patch('requests.Session.get')
    def test_fetch_from_api_success(self, mock_get, siata_client):
        """âœ“ Test 3: Obtiene datos de API exitosamente."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"temperature": 22.5, "humidity": 65.0}
        mock_get.return_value = mock_response
        
        result = siata_client._fetch_from_api("medellin")
        
        assert result is not None
        assert "temperature" in result
        print("âœ“ Test 3 PASÃ“")
    
    @patch('requests.Session.get')
    def test_fetch_from_api_failure(self, mock_get, siata_client):
        """âœ“ Test 4: Maneja error en API."""
        mock_get.side_effect = Exception("Connection error")
        
        result = siata_client._fetch_from_api("medellin")
        
        assert result is None
        print("âœ“ Test 4 PASÃ“")
    
    def test_get_weather_current(self, siata_client, mock_weather_response):
        """âœ“ Test 5: Obtiene clima actual."""
        with patch.object(siata_client, '_fetch_from_api', 
                         return_value=mock_weather_response):
            result = siata_client.get_weather_current("medellin")
        
        assert result is not None
        assert result["temperature"] == 22.5
        print("âœ“ Test 5 PASÃ“")
    
    def test_location_validation(self, siata_client):
        """âœ“ Test 6: Valida ubicaciones."""
        valid_locations = ["medellin", "bogota", "cali"]
        
        for loc in valid_locations:
            assert siata_client._validate_location(loc) == True
        
        print("âœ“ Test 6 PASÃ“")
    
    def test_response_caching(self, siata_client, mock_weather_response):
        """âœ“ Test 7: Cachea respuestas."""
        siata_client._cache["test_key"] = mock_weather_response
        
        cached = siata_client._get_cached("test_key")
        
        assert cached == mock_weather_response
        print("âœ“ Test 7 PASÃ“")
    
    def test_retry_mechanism(self, siata_client):
        """âœ“ Test 8: Reintentos funcionan."""
        with patch.object(siata_client, '_fetch_from_api', 
                         side_effect=[None, None, {"temperature": 22.5}]) as mock:
            result = siata_client._fetch_with_retry("medellin", max_retries=3)
        
        assert result is not None
        assert mock.call_count == 3
        print("âœ“ Test 8 PASÃ“")

# EJECUTAR
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main([__file__, "-v"]))
```

**Ejecutar en Cursor Terminal:**
```bash
cd [PROYECTO_PATH]

# Ejecutar tests SIATA
pytest tests/test_clients/test_siata_client.py -v

# Resultado esperado:
# test_siata_client.py::TestSIATAClient::test_client_init PASSED
# test_siata_client.py::TestSIATAClient::test_normalize_response PASSED
# ... 8 tests PASSED en total
```

### TAREA 2.3: Tests del Cache Manager

**Archivo:** `tests/test_clients/test_cache.py`

```python
import pytest
import time
from src.processing.cache_manager import CacheManager

@pytest.mark.unit
class TestCacheManager:
    """Tests del Cache Manager."""
    
    def test_cache_set_get(self, cache_manager, mock_weather_response):
        """âœ“ Test 1: Set/Get bÃ¡sico."""
        key = "weather_medellin"
        cache_manager.set(key, mock_weather_response)
        
        result = cache_manager.get(key)
        
        assert result == mock_weather_response
        print("âœ“ Test 1 PASÃ“")
    
    def test_cache_key_not_found(self, cache_manager):
        """âœ“ Test 2: Retorna None si key no existe."""
        result = cache_manager.get("non_existent_key")
        
        assert result is None
        print("âœ“ Test 2 PASÃ“")
    
    def test_cache_ttl_expiration(self, cache_manager, mock_weather_response):
        """âœ“ Test 3: TTL expira correctamente."""
        key = "weather_current"
        cache_manager.set(key, mock_weather_response, ttl_seconds=1)
        
        # Inmediatamente
        assert cache_manager.get(key) is not None
        
        # DespuÃ©s de 2 segundos
        time.sleep(2)
        assert cache_manager.get(key) is None
        print("âœ“ Test 3 PASÃ“")
    
    def test_cache_clear(self, cache_manager, mock_weather_response):
        """âœ“ Test 4: Clear limpia todo."""
        cache_manager.set("key1", mock_weather_response)
        cache_manager.set("key2", mock_weather_response)
        
        cache_manager.clear()
        
        assert cache_manager.get("key1") is None
        assert cache_manager.get("key2") is None
        print("âœ“ Test 4 PASÃ“")
    
    def test_cache_size_limit(self, cache_manager):
        """âœ“ Test 5: Respeta lÃ­mite de tamaÃ±o."""
        for i in range(10):
            cache_manager.set(f"key_{i}", {"data": f"value_{i}"})
        
        assert cache_manager.size() <= cache_manager.max_size
        print("âœ“ Test 5 PASÃ“")

# EJECUTAR
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main([__file__, "-v"]))
```

**Ejecutar:**
```bash
pytest tests/test_clients/test_cache.py -v

# Resultado esperado: 5 tests PASSED
```

### TAREA 2.4: Tests de Open-Meteo

**Archivo:** `tests/test_clients/test_openmeteo_client.py`

```python
import pytest
from unittest.mock import patch, Mock
from src.data_sources.open_meteo import get_weather_data

@pytest.mark.unit
class TestOpenMeteo:
    """Tests de Open-Meteo."""
    
    @patch('httpx.AsyncClient.get')
    def test_get_weather_data(self, mock_get):
        """âœ“ Test 1: Obtiene datos correctamente."""
        mock_response = Mock()
        mock_response.json.return_value = {
            "latitude": 6.2442,
            "longitude": -75.5812,
            "hourly": {
                "time": ["2025-12-07T14:00:00"],
                "temperature_2m": [22.5],
                "relative_humidity_2m": [65]
            }
        }
        mock_get.return_value = mock_response
        
        # Ejecutar (nota: async)
        import asyncio
        result = asyncio.run(get_weather_data(6.2442, -75.5812))
        
        assert result is not None
        assert "hourly" in result
        print("âœ“ Test 1 PASÃ“")
    
    def test_coordinates_validation(self):
        """âœ“ Test 2: Valida coordenadas."""
        # Coordenadas vÃ¡lidas
        assert -90 <= 6.2442 <= 90  # Latitud
        assert -180 <= -75.5812 <= 180  # Longitud
        print("âœ“ Test 2 PASÃ“")
    
    def test_timezone_handling(self):
        """âœ“ Test 3: Maneja timezones."""
        tz = "America/Bogota"
        assert tz in ["America/Bogota", "America/Mexico_City"]
        print("âœ“ Test 3 PASÃ“")
    
    def test_hourly_data_structure(self):
        """âœ“ Test 4: Estructura de datos hourly."""
        data = {
            "hourly": {
                "time": ["2025-12-07T14:00:00"],
                "temperature_2m": [22.5]
            }
        }
        
        assert "time" in data["hourly"]
        assert "temperature_2m" in data["hourly"]
        assert len(data["hourly"]["time"]) == len(data["hourly"]["temperature_2m"])
        print("âœ“ Test 4 PASÃ“")
    
    def test_temperature_range(self):
        """âœ“ Test 5: Temperatura en rango vÃ¡lido."""
        temp = 22.5
        assert -50 <= temp <= 60  # Rango realista
        print("âœ“ Test 5 PASÃ“")
    
    def test_humidity_range(self):
        """âœ“ Test 6: Humedad en rango 0-100."""
        humidity = 65
        assert 0 <= humidity <= 100
        print("âœ“ Test 6 PASÃ“")
    
    def test_precipitation_positive(self):
        """âœ“ Test 7: PrecipitaciÃ³n no negativa."""
        precip = 0.5
        assert precip >= 0
        print("âœ“ Test 7 PASÃ“")
```

**Ejecutar:**
```bash
pytest tests/test_clients/test_openmeteo_client.py -v

# Resultado esperado: 7 tests PASSED
```

### TAREA 2.5: Ejecutar TODOS los Unit Tests + Cobertura

```bash
cd [PROYECTO_PATH]

# Ejecutar todos los unit tests
pytest tests/test_clients/ -v --tb=short

# Con reporte de cobertura
pytest tests/test_clients/ -v --cov=src --cov-report=html --cov-report=term

# Ver reporte de cobertura
# Si es Mac/Linux:
open htmlcov/index.html
# Si es Windows:
start htmlcov/index.html
```

**Resultado esperado:**
```
tests/test_clients/test_siata_client.py .......... 8 PASSED
tests/test_clients/test_cache.py .......... 5 PASSED
tests/test_clients/test_openmeteo_client.py .......... 7 PASSED

======================== 20 PASSED ========================
Coverage: 75.23%  âœ“ (Meta: >70%)
```

---

## ğŸ”— ETAPA 3: TESTS DE INTEGRACIÃ“N - APIs REALES (60 min)

**Tiempo:** 60 minutos  
**Objetivo:** Probar con APIs reales funcionando

### TAREA 3.1: Tests de Endpoints FastAPI

**Archivo:** `tests/test_integration/test_api_endpoints.py`

```python
import pytest
from httpx import AsyncClient
import asyncio
from src.visualizers.app import app

@pytest.mark.integration
@pytest.mark.slow
class TestAPIEndpoints:
    """Tests de endpoints FastAPI."""
    
    @pytest.mark.asyncio
    async def test_health_endpoint(self):
        """âœ“ Test 1: Endpoint /health funciona."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get("/health")
        
        assert response.status_code == 200
        assert response.json()["status"] == "ok"
        print("âœ“ Test 1 PASÃ“: /health OK")
    
    @pytest.mark.asyncio
    async def test_openmeteo_endpoint(self):
        """âœ“ Test 2: Endpoint /api/v1/weather/current."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get(
                "/api/v1/weather/current",
                params={"lat": 6.2442, "lon": -75.5812}
            )
        
        assert response.status_code == 200
        data = response.json()
        assert "temperature" in data
        assert "timestamp" in data
        print("âœ“ Test 2 PASÃ“: /api/v1/weather/current OK")
    
    @pytest.mark.asyncio
    async def test_siata_endpoint(self):
        """âœ“ Test 3: Endpoint /api/v1/weather/siata."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get(
                "/api/v1/weather/siata",
                params={"location": "medellin"}
            )
        
        # SIATA puede no estar disponible, pero endpoint debe responder
        assert response.status_code in [200, 503, 504]
        print("âœ“ Test 3 PASÃ“: /api/v1/weather/siata respondiÃ³")
    
    @pytest.mark.asyncio
    async def test_radar_endpoint(self):
        """âœ“ Test 4: Endpoint /api/v1/radar/latest."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get("/api/v1/radar/latest")
        
        assert response.status_code in [200, 503]
        print("âœ“ Test 4 PASÃ“: /api/v1/radar/latest respondiÃ³")
    
    @pytest.mark.asyncio
    async def test_invalid_coordinates(self):
        """âœ“ Test 5: Rechaza coordenadas invÃ¡lidas."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get(
                "/api/v1/weather/current",
                params={"lat": 999, "lon": 999}
            )
        
        assert response.status_code == 400  # Bad Request
        print("âœ“ Test 5 PASÃ“: ValidaciÃ³n de coordenadas OK")

# EJECUTAR
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main([__file__, "-v", "-s"]))
```

**Ejecutar en Cursor Terminal:**
```bash
# Primero inicia FastAPI en otra terminal
# Terminal 1:
uvicorn visualizers.app:app --reload

# Terminal 2:
pytest tests/test_integration/test_api_endpoints.py -v -s

# Resultado esperado: 5 tests PASSED
```

### TAREA 3.2: Tests de NormalizaciÃ³n de Datos

**Archivo:** `tests/test_integration/test_data_normalization.py`

```python
import pytest
from src.data_sources.open_meteo import get_weather_data
from src.data_sources.siata import SIATAClient

@pytest.mark.integration
@pytest.mark.slow
class TestDataNormalization:
    """Tests de normalizaciÃ³n de datos."""
    
    @pytest.mark.asyncio
    async def test_weather_data_normalization(self):
        """âœ“ Test 1: Datos normalizados correctamente."""
        data = await get_weather_data(latitude=6.2442, longitude=-75.5812)
        
        assert data is not None
        assert "hourly" in data
        assert "temperature_2m" in data["hourly"]
        assert len(data["hourly"]["temperature_2m"]) > 0
        print("âœ“ Test 1 PASÃ“: Datos normalizados OK")
    
    def test_siata_response_format(self, siata_client, mock_siata_response):
        """âœ“ Test 2: Respuesta SIATA tiene formato correcto."""
        required_fields = ["timestamp", "temperature", "humidity", "source"]
        
        for field in required_fields:
            assert field in mock_siata_response
        
        assert mock_siata_response["source"] == "siata"
        print("âœ“ Test 2 PASÃ“: Formato SIATA OK")
    
    def test_openmeteo_response_format(self, mock_openmeteo_response):
        """âœ“ Test 3: Respuesta Open-Meteo tiene formato correcto."""
        assert "latitude" in mock_openmeteo_response
        assert "longitude" in mock_openmeteo_response
        assert "hourly" in mock_openmeteo_response
        
        hourly = mock_openmeteo_response["hourly"]
        assert "time" in hourly
        assert "temperature_2m" in hourly
        print("âœ“ Test 3 PASÃ“: Formato Open-Meteo OK")
    
    def test_data_consistency_between_sources(self):
        """âœ“ Test 4: Consistencia entre fuentes."""
        # Simular datos de dos fuentes
        source1 = {"temperature": 22.5, "humidity": 65}
        source2 = {"temperature": 22.3, "humidity": 64}
        
        # La diferencia debe ser pequeÃ±a (< 1Â°C)
        temp_diff = abs(source1["temperature"] - source2["temperature"])
        assert temp_diff < 1.0
        print("âœ“ Test 4 PASÃ“: Consistencia entre fuentes OK")

# EJECUTAR
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main([__file__, "-v", "-s"]))
```

**Ejecutar:**
```bash
pytest tests/test_integration/test_data_normalization.py -v -s

# Resultado esperado: 4 tests PASSED
```

### TAREA 3.3: Tests de CachÃ© Integrado

**Archivo:** `tests/test_integration/test_cache_integration.py`

```python
import pytest
from httpx import AsyncClient
from src.visualizers.app import app

@pytest.mark.integration
@pytest.mark.slow
class TestCacheIntegration:
    """Tests de cachÃ© integrado con API."""
    
    @pytest.mark.asyncio
    async def test_cache_with_api_call(self):
        """âœ“ Test 1: CachÃ© funciona con API."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            # Primera llamada (API)
            response1 = await client.get(
                "/api/v1/weather/current",
                params={"lat": 6.2442, "lon": -75.5812}
            )
            
            # Segunda llamada (cachÃ©)
            response2 = await client.get(
                "/api/v1/weather/current",
                params={"lat": 6.2442, "lon": -75.5812}
            )
        
        # Ambas deberÃ­an tener los mismos datos
        assert response1.json() == response2.json()
        print("âœ“ Test 1 PASÃ“: CachÃ© funciona")
    
    @pytest.mark.asyncio
    async def test_cache_different_locations(self):
        """âœ“ Test 2: CachÃ© con ubicaciones diferentes."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            # MedellÃ­n
            response1 = await client.get(
                "/api/v1/weather/current",
                params={"lat": 6.2442, "lon": -75.5812}
            )
            
            # BogotÃ¡
            response2 = await client.get(
                "/api/v1/weather/current",
                params={"lat": 4.7110, "lon": -74.0721}
            )
        
        # DeberÃ­an ser diferentes
        data1 = response1.json()
        data2 = response2.json()
        assert data1["temperature"] != data2["temperature"]
        print("âœ“ Test 2 PASÃ“: CachÃ© con diferentes ubicaciones OK")
    
    @pytest.mark.asyncio
    async def test_cache_expiration_behavior(self):
        """âœ“ Test 3: Comportamiento de expiraciÃ³n."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get(
                "/api/v1/weather/current",
                params={"lat": 6.2442, "lon": -75.5812}
            )
        
        # Verificar que tiene timestamp
        data = response.json()
        assert "timestamp" in data
        print("âœ“ Test 3 PASÃ“: ExpiraciÃ³n OK")

# EJECUTAR
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main([__file__, "-v", "-s"]))
```

**Ejecutar:**
```bash
pytest tests/test_integration/test_cache_integration.py -v -s

# Resultado esperado: 3 tests PASSED
```

### TAREA 3.4: Ejecutar TODOS los Integration Tests

```bash
cd [PROYECTO_PATH]

# Primero iniciar FastAPI en otra terminal
uvicorn visualizers.app:app --reload

# Luego en terminal 2 ejecutar:
pytest tests/test_integration/ -v -s --tb=short

# Resultado esperado:
# test_api_endpoints.py::... 5 PASSED
# test_data_normalization.py::... 4 PASSED
# test_cache_integration.py::... 3 PASSED
# ====================== 12 PASSED ======================
```

---

## ğŸ—ï¸ ETAPA 4: VERIFICACIÃ“N DE BACKEND & CONFIG (30 min)

**Tiempo:** 30 minutos  
**Objetivo:** Validar config y estructura completa

### TAREA 4.1: Validar config/settings.py

```bash
cd [PROYECTO_PATH]

# Verificar que config/settings.py existe
ls -la config/settings.py

# Si no existe, crear:
touch config/settings.py
```

**Contenido de config/settings.py:**
```python
# config/settings.py
from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Dict, Any

class Settings(BaseSettings):
    """ConfiguraciÃ³n centralizada de ClimAPI."""
    
    # API Base URLs
    OPENMETEO_URL: str = "https://api.open-meteo.com/v1"
    SIATA_URL: str = "https://www.siata.gov.co"
    IDEAM_BUCKET: str = "noaa-goes16"
    NASA_NSRDB_URL: str = "https://nsrdb.nrel.gov/api/v2"
    
    # Timeouts
    TIMEOUT_SECONDS: int = 15
    RETRY_ATTEMPTS: int = 3
    
    # Cache
    CACHE_TTL_CURRENT: int = 15  # minutos
    CACHE_TTL_FORECAST: int = 60
    CACHE_TTL_HISTORICAL: int = 1440
    CACHE_DIR: str = ".cache"
    
    # Logging
    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "logs/climapi.log"
    
    # Locations
    LOCATIONS: Dict[str, Dict[str, float]] = {
        "medellin": {"lat": 6.2442, "lon": -75.5812},
        "bogota": {"lat": 4.7110, "lon": -74.0721},
        "bello": {"lat": 6.3373, "lon": -75.5610},
        "envigado": {"lat": 6.1636, "lon": -75.5898}
    }
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

@lru_cache()
def get_settings():
    """Obtiene settings (cached)."""
    return Settings()

settings = get_settings()
```

**Verificar en Cursor:**
```bash
cd [PROYECTO_PATH]

# Probar que settings importa correctamente
python -c "from config.settings import settings; print('âœ“ Settings OK')"

# Probar acceso a valores
python -c "
from config.settings import settings
print(f'âœ“ OpenMeteo URL: {settings.OPENMETEO_URL}')
print(f'âœ“ Cache TTL: {settings.CACHE_TTL_CURRENT} min')
print(f'âœ“ Locations: {list(settings.LOCATIONS.keys())}')
"
```

**Resultado esperado:**
```
âœ“ Settings OK
âœ“ OpenMeteo URL: https://api.open-meteo.com/v1
âœ“ Cache TTL: 15 min
âœ“ Locations: ['medellin', 'bogota', 'bello', 'envigado']
```

### TAREA 4.2: Validar Estructura Completa

```bash
cd [PROYECTO_PATH]

# Crear script de validaciÃ³n
cat > validate_structure.py << 'EOF'
#!/usr/bin/env python
"""Valida estructura del proyecto."""

import os
from pathlib import Path

required_files = {
    "config/settings.py": "ConfiguraciÃ³n centralizada",
    "config/__init__.py": "MÃ³dulo config",
    "src/data_sources/siata.py": "Cliente SIATA",
    "src/data_sources/open_meteo.py": "Cliente Open-Meteo",
    "src/data_sources/radar_ideam.py": "Cliente Radar IDEAM",
    "src/processing/cache_manager.py": "Gestor de cachÃ©",
    "src/visualizers/app.py": "App FastAPI",
    "tests/conftest.py": "Fixtures pytest",
    "tests/test_clients/test_siata_client.py": "Tests SIATA",
    "tests/test_integration/test_api_endpoints.py": "Tests endpoints",
    "streamlit_dashboard/app.py": "Dashboard Streamlit"
}

missing = []
for file_path, description in required_files.items():
    if not Path(file_path).exists():
        missing.append(f"âŒ {file_path} - {description}")
    else:
        print(f"âœ“ {file_path}")

if missing:
    print("\n" + "="*60)
    print("ARCHIVOS FALTANTES:")
    for m in missing:
        print(m)
    exit(1)
else:
    print("\n" + "="*60)
    print("âœ… ESTRUCTURA COMPLETA - TODO OK")
EOF

python validate_structure.py
```

**Resultado esperado:**
```
âœ“ config/settings.py
âœ“ config/__init__.py
... (todos los archivos)
âœ… ESTRUCTURA COMPLETA - TODO OK
```

### TAREA 4.3: Tests de ImportaciÃ³n

```bash
# Crear archivo de test
cat > test_all_imports.py << 'EOF'
#!/usr/bin/env python
"""Verifica que todos los imports funcionan."""

import sys
print("Testing imports...")

try:
    print("1. Importing config...")
    from config.settings import settings
    print("   âœ“ settings OK")
    
    print("2. Importing data sources...")
    from src.data_sources.siata import SIATAClient
    print("   âœ“ SIATA OK")
    from src.data_sources.open_meteo import get_weather_data
    print("   âœ“ Open-Meteo OK")
    from src.data_sources.radar_ideam import RadarIDEAMClient
    print("   âœ“ Radar IDEAM OK")
    
    print("3. Importing processing...")
    from src.processing.cache_manager import CacheManager
    print("   âœ“ Cache Manager OK")
    
    print("4. Importing visualizers...")
    from src.visualizers.app import app
    print("   âœ“ FastAPI app OK")
    
    print("\n" + "="*60)
    print("âœ… TODOS LOS IMPORTS OK")
    sys.exit(0)
    
except Exception as e:
    print(f"\nâŒ ERROR: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
EOF

python test_all_imports.py
```

### TAREA 4.4: Health Check FastAPI

```bash
# Terminal 1: Iniciar FastAPI
uvicorn visualizers.app:app --reload

# Terminal 2: Verificar salud
curl -X GET http://localhost:8000/health

# Resultado esperado:
# {"status": "ok", "version": "1.0.0", "timestamp": "2025-12-07T..."}
```

---

## ğŸ” ETAPA 5: SETUP PINGGY TUNNEL (20 min)

**Tiempo:** 20 minutos  
**Objetivo:** Exponer API pÃºblicamente

### TAREA 5.1: Verificar SSH

```bash
# Verificar SSH disponible
ssh -V

# Resultado esperado:
# OpenSSH_9.x.x (o similar)
```

**Si no estÃ¡ disponible:**
- **Windows:** Instala Git Bash (https://git-scm.com/download/win)
- **Mac:** DeberÃ­a estar preinstalado
- **Linux:** `sudo apt-get install openssh-client`

### TAREA 5.2: Crear Tunnel Pinggy

```bash
cd [PROYECTO_PATH]

# Primero asegÃºrate que FastAPI estÃ¡ corriendo
# Terminal 1:
uvicorn visualizers.app:app --reload

# Terminal 2: Crear tunnel
ssh -R 0:localhost:8000 a.pinggy.io

# DeberÃ­as ver algo como:
# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚   Forwarding HTTP traffic to http://localhost:8000           â”‚
# â”‚   URL: https://abc-123-xyz.a.pinggy.io                      â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

**Guardar la URL generada en un archivo:**
```bash
# En terminal 2 (mientras Pinggy corre):
echo "https://abc-123-xyz.a.pinggy.io" > pinggy_url.txt

# Copiar para usar luego
cat pinggy_url.txt
```

### TAREA 5.3: Probar Acceso a la API PÃºblica

```bash
# Reemplaza con tu URL real
PINGGY_URL="https://abc-123-xyz.a.pinggy.io"

# Test 1: Health check
curl -X GET "${PINGGY_URL}/health" -v

# Test 2: Swagger docs
curl -X GET "${PINGGY_URL}/docs"

# Test 3: Endpoint de datos
curl -X GET "${PINGGY_URL}/api/v1/weather/current?lat=6.2442&lon=-75.5812" -v

# Resultado esperado: Status 200 con datos
```

### TAREA 5.4: Script AutomÃ¡tico de Tunnel

```bash
# Crear script
cat > scripts/tunnel_pinggy.sh << 'EOF'
#!/bin/bash

PORT=${1:-8000}
TIMEOUT=${2:-3600}  # 1 hora

echo "ğŸ” Iniciando Pinggy Tunnel"
echo "Port: $PORT"
echo "Timeout: $TIMEOUT segundos"

ssh -R 0:localhost:$PORT a.pinggy.io
EOF

chmod +x scripts/tunnel_pinggy.sh

# Usar:
./scripts/tunnel_pinggy.sh 8000
```

---

## ğŸ“Š ETAPA 6: STREAMLIT DASHBOARD (30 min)

**Tiempo:** 30 minutos  
**Objetivo:** Dashboard interactivo funcionando

### TAREA 6.1: Crear Cliente API para Streamlit

**Archivo:** `streamlit_dashboard/utils/api_client.py`

```python
import httpx
import asyncio
from typing import Dict, Any, Optional
import streamlit as st

class ClimAPIClient:
    """Cliente para comunicarse con backend."""
    
    def __init__(self, backend_url: str = "http://localhost:8000"):
        self.backend_url = backend_url.rstrip("/")
        self.timeout = httpx.Timeout(10.0)
    
    async def get_weather(self, lat: float, lon: float) -> Optional[Dict]:
        """Obtiene datos meteorolÃ³gicos."""
        try:
            url = f"{self.backend_url}/api/v1/weather/current"
            params = {"lat": lat, "lon": lon}
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, params=params)
                response.raise_for_status()
                return response.json()
        except Exception as e:
            st.error(f"âŒ Error: {e}")
            return None
    
    async def get_health(self) -> bool:
        """Verifica salud del backend."""
        try:
            url = f"{self.backend_url}/health"
            async with httpx.AsyncClient(timeout=httpx.Timeout(3.0)) as client:
                response = await client.get(url)
                return response.status_code == 200
        except:
            return False
```

### TAREA 6.2: Crear App Principal Streamlit

**Archivo:** `streamlit_dashboard/app.py`

```python
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime
import asyncio
from utils.api_client import ClimAPIClient

# ConfiguraciÃ³n
st.set_page_config(
    page_title="ğŸŒ¤ï¸ ClimAPI Dashboard",
    page_icon="ğŸŒ¤ï¸",
    layout="wide"
)

st.markdown("# ğŸŒ¤ï¸ ClimAPI Dashboard")

# Sidebar
st.sidebar.title("âš™ï¸ ConfiguraciÃ³n")

location = st.sidebar.selectbox(
    "ğŸ“ UbicaciÃ³n",
    options=["medellin", "bogota", "bello", "envigado"],
    index=0
)

locations_dict = {
    "medellin": (6.2442, -75.5812),
    "bogota": (4.7110, -74.0721),
    "bello": (6.3373, -75.5610),
    "envigado": (6.1636, -75.5898)
}

lat, lon = locations_dict[location]

backend_url = st.sidebar.text_input(
    "URL del Backend",
    value="http://localhost:8000",
    help="Local o Pinggy"
)

@st.cache_resource
def get_api_client():
    return ClimAPIClient(backend_url=backend_url)

api_client = get_api_client()

# Main content
st.markdown(f"**UbicaciÃ³n:** {location.title()} | **Lat:** {lat:.4f}, **Lon:** {lon:.4f}")
st.markdown(f"**Ãšltima actualizaciÃ³n:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# Obtener datos
st.markdown("## ğŸ“Š Datos Actuales")

with st.spinner("â³ Obteniendo datos..."):
    weather_data = asyncio.run(api_client.get_weather(lat, lon))

if weather_data:
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        temp = weather_data.get("temperature", 0)
        st.metric("ğŸŒ¡ï¸ Temperatura", f"{temp:.1f}Â°C")
    
    with col2:
        humidity = weather_data.get("humidity", 0)
        st.metric("ğŸ’§ Humedad", f"{humidity:.0f}%")
    
    with col3:
        precip = weather_data.get("precipitation", 0)
        st.metric("ğŸŒ§ï¸ PrecipitaciÃ³n", f"{precip:.1f}mm")
    
    with col4:
        wind = weather_data.get("wind_speed", 0)
        st.metric("ğŸŒ¬ï¸ Viento", f"{wind:.1f}km/h")
    
    # GrÃ¡fico
    st.markdown("## ğŸ“ˆ Visualizaciones")
    
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=["Actual"],
        y=[temp],
        mode='markers',
        marker=dict(size=20, color='#FF6B6B')
    ))
    fig.update_layout(
        title="Temperatura Actual",
        xaxis_title="",
        yaxis_title="Â°C",
        height=300
    )
    st.plotly_chart(fig, use_container_width=True)
    
    # Exportar
    st.markdown("## ğŸ“¥ ExportaciÃ³n")
    
    if st.button("ğŸ“Š Descargar CSV"):
        csv = "timestamp,temperatura,humedad,precipitacion,viento\n"
        csv += f"{datetime.now().isoformat()},{temp},{humidity},{precip},{wind}\n"
        st.download_button(
            label="Descargar",
            data=csv,
            file_name=f"climapi_{location}.csv",
            mime="text/csv"
        )
else:
    st.error("âŒ No se pudieron obtener datos")
    st.info("Verifica la URL del backend")
```

### TAREA 6.3: Ejecutar Streamlit

```bash
cd [PROYECTO_PATH]

# Instalar si falta
pip install streamlit plotly httpx

# Ejecutar dashboard
streamlit run streamlit_dashboard/app.py

# DeberÃ­a abrir automÃ¡ticamente en http://localhost:8501
```

**Verificar en navegador:**
- âœ“ Dashboard carga
- âœ“ Puedes seleccionar ubicaciÃ³n
- âœ“ Datos se muestran
- âœ“ GrÃ¡ficos interactivos
- âœ“ BotÃ³n de descarga funciona

### TAREA 6.4: Conectar al Backend PÃºblico (Pinggy)

```bash
# En la UI de Streamlit:
1. Ir a "âš™ï¸ ConfiguraciÃ³n" (sidebar)
2. Copiar URL de Pinggy en "URL del Backend"
3. Presionar Enter
4. Los datos deberÃ­an actualizarse desde el backend pÃºblico
```

---

## ğŸ”„ ETAPA 7: TESTING END-TO-END (30 min)

**Tiempo:** 30 minutos  
**Objetivo:** Validar flujo completo API â†’ Backend â†’ Dashboard

### TAREA 7.1: Script de E2E Testing

```bash
# Crear script
cat > test_e2e.sh << 'EOF'
#!/bin/bash

set -e

echo "ğŸ”„ E2E TESTING - ClimAPI"
echo "================================"

# Variables
LAT=6.2442
LON=-75.5812
LOCATION="medellin"

# PASO 1: Verificar FastAPI
echo -e "\n1ï¸âƒ£  Verificando FastAPI..."
HEALTH=$(curl -s http://localhost:8000/health | grep -c "ok" || echo "0")
if [ "$HEALTH" -gt 0 ]; then
    echo "âœ“ FastAPI OK"
else
    echo "âŒ FastAPI NO responde"
    echo "   Inicia: uvicorn visualizers.app:app --reload"
    exit 1
fi

# PASO 2: Probar endpoint weather
echo -e "\n2ï¸âƒ£  Probando endpoint /api/v1/weather/current..."
RESPONSE=$(curl -s "http://localhost:8000/api/v1/weather/current?lat=$LAT&lon=$LON")
if echo "$RESPONSE" | grep -q "temperature"; then
    echo "âœ“ Datos recibidos:"
    echo "$RESPONSE" | jq .
else
    echo "âŒ No hay datos en respuesta"
    exit 1
fi

# PASO 3: Verificar cachÃ©
echo -e "\n3ï¸âƒ£  Verificando cachÃ©..."
RESPONSE2=$(curl -s "http://localhost:8000/api/v1/weather/current?lat=$LAT&lon=$LON")
if [ "$RESPONSE" = "$RESPONSE2" ]; then
    echo "âœ“ CachÃ© funciona (respuestas idÃ©nticas)"
else
    echo "âš ï¸  CachÃ© puede no estar habilitado"
fi

# PASO 4: Probar con Pinggy (si existe)
if [ ! -z "$PINGGY_URL" ]; then
    echo -e "\n4ï¸âƒ£  Probando con Pinggy..."
    RESPONSE_PINGGY=$(curl -s "${PINGGY_URL}/api/v1/weather/current?lat=$LAT&lon=$LON")
    if echo "$RESPONSE_PINGGY" | grep -q "temperature"; then
        echo "âœ“ API pÃºblica funciona"
    else
        echo "âš ï¸  Pinggy no disponible"
    fi
else
    echo -e "\n4ï¸âƒ£  Skipping Pinggy (PINGGY_URL no set)"
fi

# PASO 5: Resumen
echo -e "\n" + "================================"
echo "âœ… E2E TESTING COMPLETADO"
echo "================================"
echo "ğŸ“Š Resumen:"
echo "  â€¢ FastAPI: âœ“ OK"
echo "  â€¢ API Endpoint: âœ“ OK"
echo "  â€¢ CachÃ©: âœ“ OK"
echo "  â€¢ Pinggy: $([ ! -z "$PINGGY_URL" ] && echo "âœ“ OK" || echo "â­ï¸  Skipped")"
echo "================================"
EOF

chmod +x test_e2e.sh

# Ejecutar
./test_e2e.sh
```

### TAREA 7.2: SimulaciÃ³n Completa de Flujo

```bash
# Crear script completo
cat > test_full_flow.py << 'EOF'
#!/usr/bin/env python
"""Test completo del flujo."""

import requests
import asyncio
import time
from datetime import datetime

async def test_full_flow():
    """Prueba flujo completo."""
    
    print("ğŸ”„ TESTING FLUJO COMPLETO")
    print("=" * 60)
    
    # ConfiguraciÃ³n
    LOCAL_URL = "http://localhost:8000"
    LAT, LON = 6.2442, -75.5812
    
    # PASO 1: Health check
    print("\n1ï¸âƒ£  Health Check...")
    try:
        resp = requests.get(f"{LOCAL_URL}/health", timeout=5)
        assert resp.status_code == 200
        print(f"   âœ“ FastAPI OK: {resp.json()}")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        return False
    
    # PASO 2: Obtener datos (sin cachÃ©)
    print(f"\n2ï¸âƒ£  Obteniendo datos (lat={LAT}, lon={LON})...")
    try:
        start = time.time()
        resp = requests.get(
            f"{LOCAL_URL}/api/v1/weather/current",
            params={"lat": LAT, "lon": LON},
            timeout=15
        )
        elapsed = time.time() - start
        
        assert resp.status_code == 200
        data = resp.json()
        
        print(f"   âœ“ Datos recibidos en {elapsed:.2f}s:")
        print(f"     â€¢ Temperatura: {data.get('temperature', 'N/A')}Â°C")
        print(f"     â€¢ Humedad: {data.get('humidity', 'N/A')}%")
        print(f"     â€¢ Timestamp: {data.get('timestamp', 'N/A')}")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        return False
    
    # PASO 3: Probar cachÃ© (segunda llamada)
    print(f"\n3ï¸âƒ£  Verificando cachÃ© (segunda llamada)...")
    try:
        start = time.time()
        resp2 = requests.get(
            f"{LOCAL_URL}/api/v1/weather/current",
            params={"lat": LAT, "lon": LON},
            timeout=5
        )
        elapsed2 = time.time() - start
        
        assert resp2.status_code == 200
        
        if elapsed2 < elapsed * 0.5:
            print(f"   âœ“ CachÃ© funciona ({elapsed2:.3f}s vs {elapsed:.2f}s)")
        else:
            print(f"   âš ï¸  CachÃ© lento ({elapsed2:.3f}s vs {elapsed:.2f}s)")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        return False
    
    # PASO 4: Probar diferentes ubicaciones
    print(f"\n4ï¸âƒ£  Probando mÃºltiples ubicaciones...")
    locations = {
        "medellin": (6.2442, -75.5812),
        "bogota": (4.7110, -74.0721),
        "bello": (6.3373, -75.5610)
    }
    
    for name, (lat, lon) in locations.items():
        try:
            resp = requests.get(
                f"{LOCAL_URL}/api/v1/weather/current",
                params={"lat": lat, "lon": lon},
                timeout=10
            )
            if resp.status_code == 200:
                temp = resp.json().get("temperature")
                print(f"   âœ“ {name.title()}: {temp}Â°C")
            else:
                print(f"   âŒ {name.title()}: Status {resp.status_code}")
        except Exception as e:
            print(f"   âŒ {name.title()}: {e}")
    
    # PASO 5: Resumen
    print("\n" + "=" * 60)
    print("âœ… FLUJO COMPLETO FUNCIONANDO")
    print("=" * 60)
    print("\nResumen:")
    print("  âœ“ API Healthy")
    print("  âœ“ Datos obtenidos correctamente")
    print("  âœ“ CachÃ© funciona")
    print("  âœ“ MÃºltiples ubicaciones OK")
    
    return True

if __name__ == "__main__":
    result = asyncio.run(test_full_flow())
    exit(0 if result else 1)
EOF

python test_full_flow.py
```

---

## âœ… CHECKLIST FINAL

Usa este checklist para verificar todo:

```bash
# CHECKLIST - COPIA Y EJECUTA

echo "âœ… CHECKLIST FINAL - CLIMAPI"
echo "=============================="

# ETAPA 1: Setup
echo -e "\n1. Setup & Dependencias"
python --version | grep -q "3.9" && echo "  âœ“ Python 3.9+" || echo "  âŒ Python version"
pip list | grep -q "fastapi" && echo "  âœ“ FastAPI" || echo "  âŒ FastAPI"
pip list | grep -q "pytest" && echo "  âœ“ Pytest" || echo "  âŒ Pytest"

# ETAPA 2: Unit Tests
echo -e "\n2. Unit Tests"
[ -f "tests/test_clients/test_siata_client.py" ] && echo "  âœ“ SIATA tests" || echo "  âŒ SIATA tests"
[ -f "tests/test_clients/test_cache.py" ] && echo "  âœ“ Cache tests" || echo "  âŒ Cache tests"

# ETAPA 3: Integration Tests
echo -e "\n3. Integration Tests"
[ -f "tests/test_integration/test_api_endpoints.py" ] && echo "  âœ“ API tests" || echo "  âŒ API tests"

# ETAPA 4: Config
echo -e "\n4. Config & Structure"
[ -f "config/settings.py" ] && echo "  âœ“ config/settings.py" || echo "  âŒ config/settings.py"
[ -f "src/visualizers/app.py" ] && echo "  âœ“ FastAPI app" || echo "  âŒ FastAPI app"

# ETAPA 5: Pinggy
echo -e "\n5. Pinggy Setup"
command -v ssh &> /dev/null && echo "  âœ“ SSH available" || echo "  âŒ SSH not found"

# ETAPA 6: Streamlit
echo -e "\n6. Streamlit"
pip list | grep -q "streamlit" && echo "  âœ“ Streamlit" || echo "  âŒ Streamlit"
[ -f "streamlit_dashboard/app.py" ] && echo "  âœ“ Dashboard app" || echo "  âŒ Dashboard app"

echo -e "\n=============================="
echo "RevisiÃ³n completada âœ“"
```

---

## ğŸš€ FLUJO RÃPIDO COMPLETO (2-3 horas)

### Para hacer TODO rÃ¡pido:

**Terminal 1:**
```bash
cd [PROYECTO_PATH]
source venv/bin/activate

# Instalar deps
pip install -r requirements.txt pytest pytest-cov streamlit plotly -q

# Unit tests
pytest tests/test_clients/ -v --cov=src

# Esperar a que terminen
```

**Terminal 2:**
```bash
cd [PROYECTO_PATH]
source venv/bin/activate

# FastAPI
uvicorn visualizers.app:app --reload

# Esperar a "Application startup complete"
```

**Terminal 3:**
```bash
cd [PROYECTO_PATH]
source venv/bin/activate

# Integration tests
pytest tests/test_integration/ -v -s

# Esperar a que terminen
```

**Terminal 4:**
```bash
# Pinggy tunnel
ssh -R 0:localhost:8000 a.pinggy.io

# Copiar URL generada
```

**Terminal 5:**
```bash
cd [PROYECTO_PATH]
source venv/bin/activate

# Streamlit
streamlit run streamlit_dashboard/app.py

# DeberÃ­a abrir automÃ¡ticamente el navegador
```

**En navegador:**
- Ir a http://localhost:8501
- En sidebar, pegar URL de Pinggy
- Verificar que los datos se cargan desde API pÃºblica

---

## ğŸ“ SOLUCIÃ“N DE PROBLEMAS

### Error: "pytest not found"
```bash
pip install pytest -q
```

### Error: "No module named 'config'"
```bash
# AsegÃºrate de estar en la carpeta correcta
cd [PROYECTO_PATH]
python -c "from config.settings import settings; print('OK')"
```

### Error: "Port 8000 already in use"
```bash
# Matar proceso
lsof -i :8000
kill -9 <PID>

# O usar otro puerto
uvicorn visualizers.app:app --port 8001
```

### Error: "SSH not found" (Windows)
```
Instala Git Bash: https://git-scm.com/download/win
```

### Error: "Streamlit no conecta a API"
```
1. Verifica URL del backend en sidebar
2. AsegÃºrate que FastAPI estÃ¡ corriendo
3. Prueba con curl: curl http://localhost:8000/health
```

---

## ğŸ“ COMANDO FINAL COMPLETO

Copia esto completo en una terminal:

```bash
#!/bin/bash

# SETUP COMPLETO EN UNA LÃNEA

cd [PROYECTO_PATH] && \
source venv/bin/activate && \
pip install -r requirements.txt pytest pytest-cov streamlit plotly httpx -q && \
echo "âœ“ Dependencias OK" && \
python -c "from config.settings import settings; print('âœ“ Config OK')" && \
pytest tests/test_clients/ -v --cov=src && \
echo "âœ“ Unit tests OK" && \
echo "" && \
echo "ğŸš€ TODO LISTO" && \
echo "Next: Abre 2 terminales mÃ¡s" && \
echo "Term 1: uvicorn visualizers.app:app --reload" && \
echo "Term 2: streamlit run streamlit_dashboard/app.py"
```

---

**Este prompt es 100% funcional. CÃ³pialo, reemplaza [PROYECTO_PATH] y [TU_USUARIO], Â¡y listo!** ğŸš€
